import torch
import numpy as np
import matplotlib.pyplot as plt
import time

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
dtype = torch.float32  

# Constants
data = np.load("/root/output/ParametricMaps/1.npz")
Nx = int(data['xSize'])
Ny = int(data['ySize'])
Nz = 6
T1 = data['T1'][:Nz, :, :]
T2 = data['T2'][:Nz, :, :]
print(f"Loaded data with shape: T1={T1.shape}, T2={T2.shape}, Nx={Nx}, Ny={Ny}, Nz={Nz}")

# Check T1/T2 values are reasonable
print(f"T1 range: {T1.min():.3f} - {T1.max():.3f} seconds")
print(f"T2 range: {T2.min():.3f} - {T2.max():.3f} seconds")

# Reshape T1/T2 to (Nx*Ny, Nz)
T1_reshaped = T1.transpose(1, 2, 0).reshape(-1, Nz)
T2_reshaped = T2.transpose(1, 2, 0).reshape(-1, Nz)
T1_reshaped = torch.tensor(T1_reshaped, device=device, dtype=dtype)
T2_reshaped = torch.tensor(T2_reshaped, device=device, dtype=dtype)

gamma_rad = 42.577e6 * 2 * np.pi
gamma = torch.tensor(gamma_rad, device=device, dtype=dtype)

class SpinSystem:
    def __init__(self, positions, T1, T2, M0=1.0):
        self.positions = positions.to(device, dtype)
        self.T1 = T1.to(device, dtype)
        self.T2 = T2.to(device, dtype)
        self.M0 = M0
        self.M = torch.zeros((len(positions), 3), device=device, dtype=dtype)
        self.M[:, 2] = M0
        
    def apply_rf_gradient(self, B1, G, t, rf_phase=0):
        dt = t[1] - t[0] if len(t) > 1 else 1e-6
        G_tensor = G.clone().detach().to(device=device, dtype=dtype) if isinstance(G, torch.Tensor) else torch.tensor(G, device=device, dtype=dtype)
        
        for i in range(len(t)):
            # Effective field
            B_eff = torch.zeros_like(self.positions)
            B_eff[:, 0] = B1[i] * np.cos(rf_phase)
            B_eff[:, 1] = B1[i] * np.sin(rf_phase)
            B_eff[:, 2] = torch.matmul(self.positions, G_tensor[i])
            
            # Rotation using Rodrigues formula
            norm_B = torch.linalg.norm(B_eff, dim=1, keepdim=True)
            mask = norm_B.squeeze() > 1e-10
            
            rotation_angle = torch.zeros(len(self.positions), device=device, dtype=dtype)
            rotation_angle[mask] = gamma * norm_B[mask].squeeze() * dt
            
            rotation_axis = torch.zeros_like(B_eff)
            rotation_axis[mask] = B_eff[mask] / norm_B[mask]
            
            # Apply rotation
            cos_theta = torch.cos(rotation_angle)
            sin_theta = torch.sin(rotation_angle)
            
            # Cross product matrix
            K = torch.zeros((len(self.positions), 3, 3), device=device, dtype=dtype)
            K[:, 0, 1] = -rotation_axis[:, 2]
            K[:, 0, 2] = rotation_axis[:, 1]
            K[:, 1, 0] = rotation_axis[:, 2]
            K[:, 1, 2] = -rotation_axis[:, 0]
            K[:, 2, 0] = -rotation_axis[:, 1]
            K[:, 2, 1] = rotation_axis[:, 0]
            
            I = torch.eye(3, device=device, dtype=dtype).unsqueeze(0).repeat(len(self.positions), 1, 1)
            rotation_matrix = (I + 
                             sin_theta.unsqueeze(-1).unsqueeze(-1) * K +
                             (1 - cos_theta).unsqueeze(-1).unsqueeze(-1) * torch.bmm(K, K))
            
            self.M = torch.bmm(rotation_matrix, self.M.unsqueeze(-1)).squeeze(-1)
            
            # Relaxation
            self.M[:, 0] *= torch.exp(-dt / self.T2)
            self.M[:, 1] *= torch.exp(-dt / self.T2)
            self.M[:, 2] = self.M0 + (self.M[:, 2] - self.M0) * torch.exp(-dt / self.T1)
    
    def apply_gradient(self, G, duration):
        """Apply gradient for a given duration with relaxation"""
        if duration <= 0:
            return
            
        G_tensor = G.to(device, dtype) if isinstance(G, torch.Tensor) else torch.tensor(G, device=device, dtype=dtype)
        
        # Phase accumulation
        phase = gamma * duration * torch.matmul(self.positions, G_tensor)
        
        # Rotate transverse magnetization
        cos_phase = torch.cos(phase)
        sin_phase = torch.sin(phase)
        
        Mx_new = self.M[:, 0] * cos_phase - self.M[:, 1] * sin_phase
        My_new = self.M[:, 0] * sin_phase + self.M[:, 1] * cos_phase
        
        # Apply relaxation
        self.M[:, 0] = Mx_new * torch.exp(-duration / self.T2)
        self.M[:, 1] = My_new * torch.exp(-duration / self.T2)
        self.M[:, 2] = self.M0 + (self.M[:, 2] - self.M0) * torch.exp(-duration / self.T1)

def design_sinc_rf(flip_angle, duration, n_lobes=4, time_bw_product=4):
    """Design a sinc RF pulse with proper windowing"""
    n_points = 256
    t = torch.linspace(-duration/2, duration/2, n_points, device=device, dtype=dtype)
    
    # Sinc envelope
    envelope = torch.sinc(time_bw_product * t / duration)
    
    # Hamming window
    window = 0.54 + 0.46 * torch.cos(2 * np.pi * torch.arange(n_points, device=device) / (n_points - 1))
    envelope *= window
    
    # Scale for desired flip angle
    dt = duration / n_points
    integral = torch.sum(envelope) * dt
    B1_scale = flip_angle / (gamma * integral)
    B1 = B1_scale * envelope
    
    return B1, t

def simulate_spin_echo_fixed(spins, Nx, TE, G_phase, FOV=0.2):
    """Fixed spin echo sequence with proper timing"""
    rf90dur = 1e-3
    rf180dur = 2e-3
    slice_thickness = 5e-3  # 5mm
    
    # Calculate slice select gradient
    time_bw = 4000  # Hz
    G_slice_amp = 2 * np.pi * time_bw / (gamma.item() * slice_thickness)
    
    # 90-degree excitation
    B1_90, t_rf = design_sinc_rf(torch.tensor(np.pi/2, device=device, dtype=dtype), rf90dur)
    G_slice = torch.zeros((len(t_rf), 3), device=device, dtype=dtype)
    G_slice[:, 2] = G_slice_amp
    spins.apply_rf_gradient(B1_90, G_slice, t_rf)
    
    # Slice rephasing
    rephase_duration = rf90dur / 2
    spins.apply_gradient(torch.tensor([0, 0, -G_slice_amp], device=device), rephase_duration)
    
    # Phase encoding
    phase_duration = 1e-3
    spins.apply_gradient(G_phase, phase_duration)
    
    # Calculate timing for TE/2
    time_to_180 = TE/2 - rf90dur/2 - phase_duration - rephase_duration
    if time_to_180 > 0:
        spins.apply_gradient(torch.zeros(3, device=device), time_to_180)
    
    # 180-degree refocusing
    B1_180, t_rf_180 = design_sinc_rf(torch.tensor(np.pi, device=device, dtype=dtype), rf180dur)
    G_slice_180 = torch.zeros((len(t_rf_180), 3), device=device, dtype=dtype)
    G_slice_180[:, 2] = G_slice_amp
    spins.apply_rf_gradient(B1_180, G_slice_180, t_rf_180, rf_phase=np.pi/2)
    
    # Readout parameters
    readout_duration = 5e-3
    readout_samples = Nx
    
    # Calculate readout gradient for proper FOV
    BW = readout_samples / readout_duration  # Bandwidth
    G_read_amp = 2 * np.pi * BW / (gamma.item() * FOV)
    G_read = torch.tensor([G_read_amp, 0, 0], device=device, dtype=dtype)
    
    # Prephasing: move to -kmax
    prephase_duration = readout_duration / 2
    spins.apply_gradient(-G_read, prephase_duration)
    
    # Time from 180Â° center to echo center (should be TE/2)
    # Echo should occur at readout center
    time_after_180 = TE/2 - rf180dur/2
    time_to_readout_start = time_after_180 - readout_duration/2 - prephase_duration
    
    if time_to_readout_start > 0:
        spins.apply_gradient(torch.zeros(3, device=device), time_to_readout_start)
    
    # Acquire signal
    signal = acquire_signal_proper(spins, G_read, readout_duration, readout_samples)
    
    return signal

def acquire_signal_proper(spins, G_read, duration, n_samples):
    """Proper signal acquisition with echo at center"""
    dt = duration / n_samples
    t_read = np.linspace(0, duration, n_samples)
    signal = np.zeros(n_samples, dtype=np.complex64)
    
    # Initial magnetization state
    M_initial = spins.M.clone()
    
    for i in range(n_samples):
        # Current time point
        t = t_read[i]
        
        # Phase from readout gradient (from -kmax to +kmax)
        k_position = -0.5 + (i / n_samples)  # Normalized k-space position
        phase = gamma.item() * G_read[0].item() * spins.positions[:, 0].cpu().numpy() * t
        
        # Get transverse magnetization
        Mxy = M_initial[:, 0].cpu().numpy() + 1j * M_initial[:, 1].cpu().numpy()
        
        # Apply phase evolution
        Mxy_phased = Mxy * np.exp(-1j * phase)
        
        # T2 decay during readout
        decay = np.exp(-t / spins.T2.cpu().numpy())
        
        # Sum signal
        signal[i] = np.sum(Mxy_phased * decay)
        
    return signal

def simulateMultiSlice(Nx, Ny, Nz, T1_data, T2_data, TE=30e-3, TR=500e-3):
    """Simulate all slices with proper k-space encoding"""
    FOV = 0.2  # 20 cm
    phase_duration = 1e-3
    
    # Calculate phase encoding gradients
    delta_ky = 1 / FOV
    ky_max = Ny / (2 * FOV)
    ky_values = np.linspace(-ky_max, ky_max, Ny)
    G_phase_amplitudes = ky_values / (gamma.item() * phase_duration)
    
    k_space = np.zeros((Ny, Nz, Nx), dtype=np.complex64)
    
    print("Starting multi-slice simulation...")
    start_time = time.time()
    
    # Store example signals
    debug_signals = {
        'center' : [],
        'quarter' : [],
        'edge' : [],
    }
    
    # Simulate ALL slices
    for slice_idx in range(3, Nz):
        print(f"Simulating slice {slice_idx+1}/{Nz}")
        
        # Create positions for this slice
        x = torch.linspace(-FOV/2, FOV/2, Nx, device=device, dtype=dtype)
        y = torch.linspace(-FOV/2, FOV/2, Ny, device=device, dtype=dtype)
        z_pos = slice_idx * 5e-3  # 5mm slice spacing
        z = torch.tensor([z_pos], device=device, dtype=dtype)
        
        X, Y, Z = torch.meshgrid(x, y, z, indexing='ij')
        positions = torch.stack([X.flatten(), Y.flatten(), Z.flatten()], dim=1)
        
        # Initialize spins for this slice
        spins = SpinSystem(positions, T1_data[:, slice_idx], T2_data[:, slice_idx])
        
        # Acquire all phase encoding steps
        for pe_idx in range(Ny):
            # Phase encoding gradient
            G_phase = torch.tensor([0, G_phase_amplitudes[pe_idx], 0], device=device, dtype=dtype)
            
            # Run sequence
            signal = simulate_spin_echo_fixed(spins, Nx, TE, G_phase, FOV)
            k_space[pe_idx, slice_idx, :] = signal
            
            # Save debug signals from middle slice
            if pe_idx == Ny // 2:
                debug_signals['center'][slice_idx] = signal
            elif pe_idx == Ny // 4:
                debug_signals['quarter'][slice_idx] = signal
            elif pe_idx == 0:
                debug_signals['edge'][slice_idx] = signal
            
            # TR period - let magnetization recover
            remaining_TR = TR - TE
            if remaining_TR > 0:
                spins.apply_gradient(torch.zeros(3, device=device), remaining_TR)
            
            # Spoil transverse magnetization
            spins.M[:, 0] = 0
            spins.M[:, 1] = 0


        reconstruct_and_display(k_space, debug_signals, slice_idx)

    
    elapsed = time.time() - start_time
    print(f"Simulation completed in {elapsed:.1f} seconds")
    
    return k_space, debug_signals

def reconstruct_and_display(k_space, debug_signals, slice_idx):
    """Reconstruct images and create display"""
    fig = plt.figure(figsize=(16, 12))
    
    # Display middle slice
    k_slice = k_space[:, slice_idx, :]
    
    # Row 1: k-space
    ax1 = plt.subplot(3, 3, 1)
    k_mag = np.log(np.abs(k_slice) + 1e-10)
    im1 = ax1.imshow(k_mag, cmap='gray', aspect='auto')
    ax1.set_title('k-Space Magnitude (log)')
    ax1.set_xlabel('kx (readout)')
    ax1.set_ylabel('ky (phase)')
    plt.colorbar(im1, ax=ax1, fraction=0.046)
    
    ax2 = plt.subplot(3, 3, 2)
    k_phase = np.angle(k_slice)
    im2 = ax2.imshow(k_phase, cmap='hsv', aspect='auto')
    ax2.set_title('k-Space Phase')
    ax2.set_xlabel('kx (readout)')
    ax2.set_ylabel('ky (phase)')
    plt.colorbar(im2, ax=ax2, fraction=0.046)
    
    # Reconstruct image
    image = np.fft.fftshift(np.fft.ifft2(np.fft.ifftshift(k_slice)))
    image_mag = np.abs(image)
    
    ax3 = plt.subplot(3, 3, 3)
    im3 = ax3.imshow(image_mag, cmap='gray')
    ax3.set_title('Reconstructed Image')
    ax3.set_xlabel('x (pixels)')
    ax3.set_ylabel('y (pixels)')
    plt.colorbar(im3, ax=ax3, fraction=0.046)
    
    # Row 2: Signals
    time_ms = np.linspace(0, 5, len(debug_signals['center'][slice_idx]))
    
    ax4 = plt.subplot(3, 3, 4)
    ax4.plot(time_ms, np.abs(debug_signals['center'][slice_idx]))
    ax4.set_title('Signal at center phase')
    ax4.set_xlabel('Time (ms)')
    ax4.set_ylabel('Signal magnitude')
    ax4.grid(True, alpha=0.3)
    
    ax5 = plt.subplot(3, 3, 5)
    ax5.plot(time_ms, np.abs(debug_signals['quarter'][slice_idx]))
    ax5.set_title('Signal at ky=Ny/4')
    ax5.set_xlabel('Time (ms)')
    ax5.set_ylabel('Signal magnitude')
    ax5.grid(True, alpha=0.3)
    
    ax6 = plt.subplot(3, 3, 6)
    ax6.plot(time_ms, np.abs(debug_signals['edge'][slice_idx]))
    ax6.set_title('Signal at ky edge')
    ax6.set_xlabel('Time (ms)')
    ax6.set_ylabel('Signal magnitude')
    ax6.grid(True, alpha=0.3)
    
    # Row 3: Different slices
    '''for i, slice_idx in enumerate([0, k_space.shape[1]//2, k_space.shape[1]-1]):
        ax = plt.subplot(3, 3, 7+i)
        k_slice = k_space[:, slice_idx, :]
        image = np.fft.fftshift(np.fft.ifft2(np.fft.ifftshift(k_slice)))
        ax.imshow(np.abs(image), cmap='gray')
        ax.set_title(f'Slice {slice_idx+1}')
        ax.set_xlabel('x')
        ax.set_ylabel('y')'''
    
    plt.tight_layout()
    plt.savefig(f'/root/output/ReconstructedMRI/result{slice_idx}.png', dpi=300)
    plt.show()
    
    # Print diagnostics
    print(f"\nDiagnostics:")
    print(f"k-space shape: {k_space.shape}")
    print(f"k-space magnitude range: [{np.abs(k_space).min():.3e}, {np.abs(k_space).max():.3e}]")
    print(f"Image magnitude range: [{image_mag.min():.3f}, {image_mag.max():.3f}]")
    print(f"Peak signal position in readout: {np.argmax(np.abs(debug_signals['center']))} / {len(debug_signals['center'][slice_idx])}")

if __name__ == "__main__":
    # Run the complete simulation
    k_space, debug_signals = simulateMultiSlice(Nx, Ny, Nz, T1_reshaped, T2_reshaped, TE=30e-3, TR=500e-3)
    