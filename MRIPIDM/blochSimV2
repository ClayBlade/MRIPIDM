import torch
import numpy as np
import matplotlib.pyplot as plt
import time

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
dtype = torch.float32  

# Constants
data = np.load("/root/output/ParametricMaps/1.npz")
Nx = int(data['xSize'])
Ny = int(data['ySize'])
Nz = 2  # Number of slices
T1 = data['T1'][:Nz, :, :]
T2 = data['T2'][:Nz, :, :]
print(f"Loaded data with shape: T1={T1.shape}, T2={T2.shape}, Nx={Nx}, Ny={Ny}, Nz={Nz}")

# Reshape T1/T2 to (Nx*Ny, Nz)
T1_reshaped = T1.transpose(1, 2, 0).reshape(-1, Nz)
T2_reshaped = T2.transpose(1, 2, 0).reshape(-1, Nz)
T1_reshaped = torch.tensor(T1_reshaped, device=device, dtype=dtype)
T2_reshaped = torch.tensor(T2_reshaped, device=device, dtype=dtype)

print(f"T1_reshaped shape: {T1_reshaped.shape}")
print(f"T2_reshaped shape: {T2_reshaped.shape}")

gamma_rad = 42.577e6 * 2 * np.pi
gamma = torch.tensor(gamma_rad, device=device, dtype=dtype)

class SpinSystem:
    def __init__(self, positions, T1, T2, M0=1.0):
        self.positions = positions.to(device, dtype)
        self.T1 = T1.to(device, dtype)
        self.T2 = T2.to(device, dtype)
        self.M0 = M0
        self.M = torch.zeros((len(positions), 3), device=device, dtype=dtype)
        self.M[:, 2] = M0
        self.rotation_matrices = torch.eye(3, device=device, dtype=dtype).repeat(len(positions), 1, 1)

    def apply_rf_gradient(self, B1, G, t, rf_phase=0):
        dt = t[1] - t[0]
        G_tensor = G.clone().detach().to(device=device, dtype=dtype) if isinstance(G, torch.Tensor) else torch.tensor(G, device=device, dtype=dtype)
        
        for i in range(len(t)):
            B_eff = torch.zeros_like(self.positions)
            B_eff[:, 0] = B1[i] * np.cos(rf_phase)
            B_eff[:, 1] = B1[i] * np.sin(rf_phase)
            B_eff[:, 2] = torch.matmul(self.positions, G_tensor[i])

            norm_B = torch.linalg.norm(B_eff, dim=1, keepdim=True)
            rotation_angle = gamma * norm_B.squeeze() * dt
            rotation_axis = B_eff / norm_B
            
            cos_theta = torch.cos(rotation_angle)
            sin_theta = torch.sin(rotation_angle)
            
            K = torch.zeros((len(self.positions), 3, 3), device=device, dtype=dtype)
            K[:, 0, 1] = -rotation_axis[:, 2]
            K[:, 0, 2] = rotation_axis[:, 1]
            K[:, 1, 0] = rotation_axis[:, 2]
            K[:, 1, 2] = -rotation_axis[:, 0]
            K[:, 2, 0] = -rotation_axis[:, 1]
            K[:, 2, 1] = rotation_axis[:, 0]
            
            I = torch.eye(3, device=device, dtype=dtype).repeat(len(self.positions), 1, 1)
            self.rotation_matrices = (
                I + 
                sin_theta.unsqueeze(-1).unsqueeze(-1) * K +
                (1 - cos_theta).unsqueeze(-1).unsqueeze(-1) * torch.matmul(K, K)
            )
            
            self.M = torch.bmm(self.rotation_matrices, self.M.unsqueeze(-1)).squeeze(-1)
            
            decay_factor = torch.exp(-dt / self.T2).unsqueeze(1)
            self.M[:, :2] *= decay_factor
            self.M[:, 2] = self.M0 - (self.M0 - self.M[:, 2]) * torch.exp(-dt / self.T1)

    def apply_gradient(self, G, duration):
        if isinstance(G, torch.Tensor):
            G_tensor = G.to(device, dtype)
        else:
            G_tensor = torch.tensor(G, device=device, dtype=dtype)
        phase_accumulation = gamma * duration * torch.matmul(self.positions, G_tensor)
        
        Mxy = self.M[:, 0] + 1j * self.M[:, 1]
        Mxy = Mxy * torch.exp(-1j * phase_accumulation)
        
        decay = torch.exp(-duration / self.T2)
        Mxy *= decay
        self.M[:, 2] = self.M0 - (self.M0 - self.M[:, 2]) * torch.exp(-duration / self.T1)
        
        self.M[:, 0] = Mxy.real
        self.M[:, 1] = Mxy.imag

    def acquire_signal(self, G_read, t_read, adc_delay=0):
        dt = t_read[1] - t_read[0]
        signal = torch.zeros(len(t_read), dtype=torch.complex64, device=device)
        
        if adc_delay > 0:
            self.apply_gradient(G_read, adc_delay)
        
        for i, ti in enumerate(t_read):
            self.apply_gradient(G_read, dt)
            signal[i] = torch.sum(self.M[:, 0] + 1j * self.M[:, 1])
        return signal.cpu().numpy()

    def reset_magnetization(self):
        self.M[:, :] = 0
        self.M[:, 2] = self.M0

def design_sinc_rf(flip_angle, duration, n_lobes=4):
    t = torch.linspace(-duration/2, duration/2, 100, device=device, dtype=dtype)
    lobe_factor = 4 * n_lobes / duration
    envelope = torch.sinc(lobe_factor * t)

    window = torch.hamming_window(len(t), device=device)
    envelope *= window
    
    area = torch.trapz(envelope, t)
    B1_max = flip_angle / (gamma * area)
    B1 = B1_max * envelope
    
    return B1, t

def simulate_spin_echo(spins, Nx, TE, G_phase): 
    rf90dur = 2e-3
    rf180dur = 2e-3
    
    B1, t_rf = design_sinc_rf(torch.tensor(np.pi/2, device=device, dtype=dtype), rf90dur)
    G_slice = torch.zeros(3, device=device, dtype=dtype)
    spins.apply_rf_gradient(B1, G_slice.repeat(len(t_rf), 1), t_rf)
    
    spins.apply_gradient(G_phase, 2e-3)

    wait_time = TE/2 - (rf90dur + rf180dur/2 + 2e-3) #2e-3 = Gy dur
    if wait_time > 0:
        spins.apply_gradient(torch.zeros(3, device=device), wait_time)

    B1_refocus, t_rf_refocus = design_sinc_rf(torch.tensor(np.pi, device=device, dtype=dtype), rf180dur)
    spins.apply_rf_gradient(B1_refocus, G_slice.repeat(len(t_rf_refocus), 1), t_rf_refocus)
    
    wait_time = TE/2 - (rf180dur/2 + (5e-3)/2) # (5e-3) = Gx since Gx occurs at the same time as readout
    if wait_time > 0:
        spins.apply_gradient(torch.zeros(3, device=device), wait_time)

    t_read = torch.linspace(-2.5e-3, 2.5e-3, Nx, device=device, dtype=dtype)
    G_read = torch.tensor([0.03, 0, 0], device=device, dtype=dtype)
    signal = spins.acquire_signal(G_read, t_read.cpu().numpy())

    #maybe relaxation in the tr
    
    
    return signal, spins, B1

def simulateMultiTR(Nx, Ny, Nz, T1_data, T2_data, TE=12e-3, TR=700-3):
    G_phase_amp = torch.linspace(-0.1, 0.1, Ny, device=device, dtype=dtype)
    k_space = torch.zeros((Ny, Nz, Nx), dtype=torch.complex64, device=device)

    print("Starting simulation...")
    start_time = time.time()

    for slice_idx in range(Nz):
        print(f"Simulating slice {slice_idx+1}/{Nz}")
        x = torch.linspace(-0.1, 0.1, Nx, device=device, dtype=dtype)
        y = torch.linspace(-0.1, 0.1, Ny, device=device, dtype=dtype)
        z = torch.tensor([0.0], device=device, dtype=dtype)
        X, Y, Z = torch.meshgrid(x, y, z, indexing='ij')
        positions = torch.stack([X.flatten(), Y.flatten(), Z.flatten()], dim=1)
    
        spins = SpinSystem(positions, T1_data[:, slice_idx], T2_data[:, slice_idx])

        for phase_idx in range(Ny):
            G_phase = torch.tensor([0, float(G_phase_amp[phase_idx]), 0], 
                                  device=device, dtype=dtype)

            signal, spins, B1= simulate_spin_echo(spins, Nx, TE, G_phase)
            

            wait_time = TR - TE - 2.5e-3 #2.5e-3 is half of the readout
            spins.apply_gradient(torch.zeros(3, device=device), wait_time)

            k_space[phase_idx, slice_idx, :] = torch.tensor(signal, device=device)

    print(f"Simulation completed in {time.time() - start_time:.2f} seconds")

    print("Final magnetization state:")
    print(f"  Mx: min={spins.M[:,0].min().item():.4f}, max={spins.M[:,0].max().item():.4f}")
    print(f"  My: min={spins.M[:,1].min().item():.4f}, max={spins.M[:,1].max().item():.4f}")
    print(f"  Mz: min={spins.M[:,2].min().item():.4f}, max={spins.M[:,2].max().item():.4f}")

    print(f"Gamma value: {gamma.item()} rad/s/T")
    print(f"Expected gamma: {42.577e6 * 2 * np.pi} rad/s/T")

    print(f"Position range: x={spins.positions[:, 0].min().item()}-{spins.positions[:, 0].max().item()}m, "
      f"y={spins.positions[:, 1].min().item()}-{spins.positions[:, 1].max().item()}m")

    print(f"RF Pulse: Duration={2e-3}s, Max B1={B1.max().item()}T")
    return k_space.cpu().numpy(), B1, signal


def plot_signal_evolution(signals, B1):
    """Plot signal evolution through sequence"""
    plt.figure(figsize=(12, 4))
    
    # Plot RF pulse
    plt.subplot(131)
    plt.plot(B1.cpu().numpy())
    plt.title("RF Pulse Profile")
    
    # Plot k-space magnitude
    plt.subplot(132)
    plt.imshow(np.log(np.abs(k_space[:, Nz-1, :]) + 1e-9), cmap='viridis')
    plt.title("k-Space Magnitude")
    
    # Plot signal through readout
    plt.subplot(133)
    plt.plot(np.abs(signals[0]))
    plt.title("First Readout Signal")
    
    plt.tight_layout()
    plt.savefig("/root/output/ReconstructedMRI/debug.png")

def reconstruct_image(k_space_slice):
    k_centered = np.fft.ifftshift(k_space_slice)
    image = np.fft.ifft2(k_centered)
    return np.abs(image)

if __name__ == "__main__":
    k_space, B1, signal= simulateMultiTR(Nx, Ny, Nz, T1_reshaped, T2_reshaped)
    
    try: 
        plot_signal_evolution(signal, B1)
    except:
        print("debug error")

    # Display center slice
    center_slice_idx = Nz - 1
    k_space_slice = k_space[:, center_slice_idx, :]
    
    fig, axes = plt.subplots(1, 5, figsize=(15, 5))
    
    axes[0].imshow(np.log(np.abs(k_space_slice) + 1e-9), cmap='viridis')
    axes[0].set_title("k-Space (Magnitude)")
    
    recon_image = reconstruct_image(k_space_slice)
    axes[1].imshow(recon_image, cmap='gray')
    axes[1].set_title("Reconstructed Image")
    
    diff_image = np.abs(recon_image - np.rot90(recon_image, 2))
    axes[2].imshow(diff_image, cmap='hot')
    axes[2].set_title("Symmetry Difference")

    # Use same slice index for T1/T2 display
    t1_slice = data["T1"][center_slice_idx, :, :]
    axes[3].imshow(t1_slice.T, origin='lower', cmap='viridis')
    axes[3].set_title("T1 map")

    t2_slice = data["T2"][center_slice_idx, :, :]
    axes[4].imshow(t2_slice.T, origin='lower', cmap='viridis')
    axes[4].set_title("T2 map")
    
    plt.tight_layout()
    plt.savefig("/root/output/ReconstructedMRI/results.png", dpi=300)
    plt.show()