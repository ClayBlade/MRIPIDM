import torch
import numpy as np
import matplotlib.pyplot as plt
from scipy.spatial.transform import Rotation
import time
from datetime import date

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
dtype = torch.float32  

# Constants
data = np.load("D:/Projects/MRIPIDMoutput/test.npz") #  "D:/Projects/MRIPIDMoutput/ParametricMaps/1.npz" or "/root/output/ParametricMaps/1.npz" or "D:/Projects/MRIPIDMoutput/test.npz" or "/root/output/ParametricMaps/test.npz"
Nx = int(data['xSize'])
Ny = int(data['ySize'])
Nz = int(data['zSize'])
T1 = data['T1']
T2 = data['T2']
print(f"Loaded data with shape: T1={T1.shape}, T2={T2.shape}, Nx={Nx}, Ny={Ny}, Nz={Nz}")

T1vert = np.zeros((len(T1), Nz), dtype=np.float32)
T2vert = np.zeros((len(T2), Nz), dtype=np.float32)

history = []

T1_reshaped = T1.transpose(1, 2, 0).reshape(-1, Nz)
T2_reshaped = T2.transpose(1, 2, 0).reshape(-1, Nz)
T1_reshaped = torch.tensor(T1_reshaped, device=device, dtype=dtype)
T2_reshaped = torch.tensor(T2_reshaped, device=device, dtype=dtype)

print(f"T1_reshaped shape: {T1_reshaped.shape}")  # Should be (Nx*Ny, Nz)
print(f"T2_reshaped shape: {T2_reshaped.shape}")  # Should be (Nx*Ny, Nz)


gamma_rad = 42.577e6 * 2 * np.pi  # Original value
gamma = torch.tensor(gamma_rad, device=device, dtype=dtype)  # GPU tensor

#history = []

class SpinSystem:
    def __init__(self, positions, T1, T2, M0=1.0):
        """
        Initialize the spin system.
        
        Parameters:
            positions (np.array): (N, 3) array of spin positions
            T1 (np.array): (N,) array of T1 values
            T2 (np.array): (N,) array of T2 values
            M0 (float): Equilibrium magnetization
        """
        self.positions = positions.to(device, dtype)
        self.T1 = T1.to(device, dtype)
        self.T2 = T2.to(device, dtype)
        self.M0 = M0

        self.M = torch.zeros((len(positions), 3), device=device, dtype=dtype)
        self.M[:, 2] = M0  # Initialize to equilibrium magnetization

        self.rotation_matrices = torch.eye(3, device=device, dtype=dtype).repeat(len(positions), 1, 1)


    def apply_rf_gradient(self, B1, G, t, rf_phase=0):
        dt = t[1] - t[0]


        G_tensor = G.clone().detach().to(device=device, dtype=dtype) if isinstance(G, torch.Tensor) else torch.tensor(G, device=device, dtype=dtype)
        
        for i in range(len(t)):
            # Effective B-field 
            B_eff = torch.zeros_like(self.positions)
            B_eff[:, 0] = B1[i] * np.cos(rf_phase)
            B_eff[:, 1] = B1[i] * np.sin(rf_phase)
            B_eff[:, 2] = torch.matmul(self.positions, G_tensor[i])

             # Compute rotation angles and axes
            norm_B = torch.linalg.norm(B_eff, dim=1, keepdim=True)
            rotation_angle = gamma * norm_B.squeeze() * dt
            rotation_axis = B_eff / norm_B
            
            # Compute rotation matrices using Rodrigues' formula
            cos_theta = torch.cos(rotation_angle)
            sin_theta = torch.sin(rotation_angle)
            
            # Cross product matrix K = [[0, -k_z, k_y], [k_z, 0, -k_x], [-k_y, k_x, 0]]
            K = torch.zeros((len(self.positions), 3, 3), device=device, dtype=dtype)
            K[:, 0, 1] = -rotation_axis[:, 2]
            K[:, 0, 2] = rotation_axis[:, 1]
            K[:, 1, 0] = rotation_axis[:, 2]
            K[:, 1, 2] = -rotation_axis[:, 0]
            K[:, 2, 0] = -rotation_axis[:, 1]
            K[:, 2, 1] = rotation_axis[:, 0]
            
            # Rodrigues' rotation formula
            I = torch.eye(3, device=device, dtype=dtype).repeat(len(self.positions), 1, 1)
            self.rotation_matrices = (
                I + 
                sin_theta.unsqueeze(-1).unsqueeze(-1) * K +
                (1 - cos_theta).unsqueeze(-1).unsqueeze(-1) * torch.matmul(K, K)
            )
            
            # Apply rotation
            self.M = torch.bmm(self.rotation_matrices, self.M.unsqueeze(-1)).squeeze(-1)
            
            # Apply relaxation
            decay_factor = torch.exp(-dt / self.T2).unsqueeze(1)
            self.M[:, :2] *= decay_factor

            self.M[:, 2] = self.M0 - (self.M0 - self.M[:, 2]) * torch.exp(-dt / self.T1)
            
        #print(f"RF Pulse: Max B1={torch.max(B1):.4f} T, Min B1={torch.min(B1):.4f} T")
        #print(f"Rotation angles: Min={torch.min(rotation_angle):.4f} rad, Max={torch.max(rotation_angle):.4f} rad")
            
        

    def apply_gradient(self, G, duration):
        #history_grad.append(self.M.copy())
        # Phase accumulation
        if isinstance(G, torch.Tensor):
            G_tensor = G.to(device, dtype)
        else:
            G_tensor = torch.tensor(G, device=device, dtype=dtype)
        phase_accumulation = gamma * duration * torch.matmul(self.positions, G_tensor)
        
        # GPU-compatible complex operations
        Mxy = self.M[:, 0] + 1j * self.M[:, 1]
        Mxy = Mxy * torch.exp(-1j * phase_accumulation)
        
        # Relaxation
        decay = torch.exp(-duration / self.T2)  # Use torch.exp instead of np.exp
        Mxy *= decay
        self.M[:, 2] = self.M0 - (self.M0 - self.M[:, 2]) * torch.exp(-duration / self.T1)
        
        # Convert back
        self.M[:, 0] = Mxy.real
        self.M[:, 1] = Mxy.imag
        
        #print(f"Gradient: {G_tensor} T/m, Duration={duration:.4f}s")
        #print(f"Phase accumulation: Min={torch.min(phase_accumulation):.4f} rad, Max={torch.max(phase_accumulation):.4f} rad")



    def acquire_signal(self, G_read, t_read, adc_delay=0):
        """
        Acquire signal during readout gradient.
        
        Parameters:
            G_read (np.array): Readout gradient (T/m)
            t_read (np.array): Readout time points (s)
            adc_delay (float): Delay before ADC starts (s)
            
        Returns:
            np.array: Acquired signal (complex)
        """
        dt = t_read[1] - t_read[0]
        signal = torch.zeros(len(t_read), dtype=torch.complex64, device=device)
        
        
        # Apply ADC delay
        if adc_delay > 0:
            #print("ADC delay")
            self.apply_gradient(G_read, adc_delay)
            #print("\n")

        
        # Readout loop
        for i, ti in enumerate(t_read):
            # Apply gradient for one timestep
            #print("ReadLoop")
            self.apply_gradient(G_read, dt)
            #print("\n")


            # Sum transverse magnetization
            signal[i] = torch.sum(self.M[:, 0] + 1j * self.M[:, 1]) / len(self.M)

        Mxy = self.M[:, 0] + 1j * self.M[:, 1]
        #print(f"ADC Sample {i}: Max |Mxy|={torch.max(torch.abs(Mxy)):.6f}, Avg |Mxy|={torch.mean(torch.abs(Mxy)):.6f}") #Max Mxy = Avg Mxy

        return signal.cpu().numpy()

    def reset_magnetization(self):
        """Reset magnetization to equilibrium."""
        self.M[:, :] = 0
        self.M[:, 2] = self.M0

def design_sinc_rf(flip_angle, duration, n_lobes=4, bandwidth=2000):
    t = torch.linspace(-duration/2, duration/2, 100, device=device, dtype=dtype)
    lobe_factor = 4 * n_lobes / duration
    envelope = torch.sinc(lobe_factor * t)
    
    # Normalize envelope to peak=1 and scale
    envelope = envelope / torch.max(envelope) * flip_angle
    
    # Calculate area
    area = torch.trapz(envelope, t) * 1e-6
    B1_max = flip_angle / (gamma * area)
    
    # DEBUG 
    #print(f"Design_sinc_pulse: \n        RF Pulse: Area={area.item():.4f}, B1_max={B1_max.item():.6f} T")
    
    return B1_max * envelope, t


def simulate_spin_echo(Nx, Ny, TE, T1_data, T2_data, G_phase):
    # Create positions for one slice
    x = torch.linspace(-0.05, 0.05, Nx, device=device, dtype=dtype)
    y = torch.linspace(-0.05, 0.05, Ny, device=device, dtype=dtype)
    z = torch.tensor([0.0], device=device, dtype=dtype)
    X, Y, Z = torch.meshgrid(x, y, z, indexing='ij')
    positions = torch.stack([X.flatten(), Y.flatten(), torch.full((Nx*Ny,), 0.1, device = device)], dim=1)

    

    # Use T1/T2 values for slice k
    T1_slice = T1_data  
    T2_slice = T2_data 

    #spins = SpinSystem(positions, T1_slice, T2_slice)
    spins = SpinSystem(positions[0:1], torch.tensor([1.0], device=device), torch.tensor([0.1], device=device))
    


    # Timing parameters
    rf90dur = 2e-3
    rf180dur = 2e-3
    
    
    # 90° excitation - returns PyTorch tensors
    #print("90 degree RF")
    B1, t_rf = design_sinc_rf(torch.tensor(np.pi/2, device=device, dtype=dtype), rf90dur)
    G_slice = torch.zeros(3, device=device, dtype=dtype)
    spins.apply_rf_gradient(B1, G_slice.repeat(len(t_rf), 1), t_rf)
    #print("\n")
    
    
    # Phase encoding
    #print("Phase encode")
    spins.apply_gradient(G_phase, 2e-3)  # Gphase_dur = 2e-3
    #print("\n")

    
    # Wait TE/2
    #print("Wait1")
    wait_time = TE/2 - (rf90dur/2 + rf180dur/2 + 1e-3 + 2e-3)  # rephasedur=1e-3, Gphase_dur=2e-3
    if wait_time > 0:
        spins.apply_gradient(torch.zeros(3, device=device), wait_time)
    #print("\n")

    
    # 180° refocusing
    #print("180 degree RF")
    B1_refocus, t_rf_refocus = design_sinc_rf(torch.tensor(np.pi, device=device, dtype=dtype), rf180dur)
    spins.apply_rf_gradient(B1_refocus, G_slice.repeat(len(t_rf_refocus), 1), t_rf_refocus)
    #print("\n")

    # Wait TE/2
    wait_time = TE/2 - (rf180dur/2 + 5e-3/2 + 2.5e-3)  # Gread_dur=5e-3, Greadrephasedur=2.5e-3
    if wait_time > 0:
        #print("wait2")
        spins.apply_gradient(torch.zeros(3, device=device), wait_time)
        #print("\n")


    # Readout
    t_read = torch.linspace(0, 5e-3, Nx, device=device, dtype=dtype)  # Gread_dur=5e-3
    G_read = torch.tensor([3e-5, 0, 0], device=device, dtype=dtype)
    #print("AcqSig")
    signal = spins.acquire_signal(G_read, t_read.cpu().numpy())

    #history.append(spins.M)

    return signal, spins, t_rf, B1

def simulateMultiTR(Nx, Ny, Nz, T1_data, T2_data, TE=12e-3, TR=100e-3):
    """Simulate multi-TR acquisition"""
    G_phase_amp = torch.linspace(-0.01, 0.01, Ny, device=device, dtype=dtype)
    k_space = torch.zeros((Ny, Nz, Nx), dtype=torch.complex64, device=device)

    # Warm-up GPU
    print("Warming up GPU...")
    warm_up_spins = SpinSystem(
        torch.rand(100, 3, device=device, dtype=dtype), #Need 3 there or else err
        torch.rand(100, device=device, dtype=dtype),
        torch.rand(100, device=device, dtype=dtype)
    )
    warm_up_spins.apply_gradient(torch.zeros(3, device=device), 1e-3)

    print("Starting simulation...")
    start_time = time.time()

    for slice_idx in range(Nz):
        for phase_idx in range(Ny):
            print("---------")
            print(f"slice_idx: {slice_idx}, phase_idx: {phase_idx}")
            G_phase = torch.tensor([0, float(G_phase_amp[phase_idx])/1000, 0], 
                                  device=device, dtype=dtype)
            
            signal, spins ,t , B1 = simulate_spin_echo(Nx, Ny, TE, T1_data[:, slice_idx], T2_data[:, slice_idx], G_phase)
            
            k_space[phase_idx, slice_idx, :] = torch.tensor(signal, device=device)
            
            # Wait until next TR
            wait_time = TR - (TE + 5e-3)  # Adjust based on sequence timing
            if wait_time > 0:
                # Dummy operation to maintain timing
                pass

    print(f"Simulation completed in {time.time() - start_time:.2f} seconds")

    print("Final magnetization state:")
    print(f"  Mx: min={spins.M[:,0].min().item():.4f}, max={spins.M[:,0].max().item():.4f}")
    print(f"  My: min={spins.M[:,1].min().item():.4f}, max={spins.M[:,1].max().item():.4f}")
    print(f"  Mz: min={spins.M[:,2].min().item():.4f}, max={spins.M[:,2].max().item():.4f}")

    print(f"Gamma value: {gamma.item()} rad/s/T")
    print(f"Expected gamma: {42.577e6 * 2 * np.pi} rad/s/T")

    print(f"Position range: x={spins.positions[:, 0].min().item()}-{spins.positions[:, 0].max().item()}m, "
      f"y={spins.positions[:, 1].min().item()}-{spins.positions[:, 1].max().item()}m")

    print(f"RF Pulse: Duration={2e-3}s, Max B1={B1.max().item()}T")

    
    
    return k_space.cpu().numpy(), t, B1

def plot_signal_evolution(signals, B1):
    """Plot signal evolution through sequence"""
    plt.figure(figsize=(12, 4))
    
    # Plot RF pulse
    plt.subplot(131)
    plt.plot(B1.cpu().numpy())
    plt.title("RF Pulse Profile")
    
    # Plot k-space magnitude
    plt.subplot(132)
    plt.imshow(np.log(np.abs(k_space[:, Nz//2, :]) + 1e-9), cmap='viridis')
    plt.title("k-Space Magnitude")
    
    # Plot signal through readout
    plt.subplot(133)
    plt.plot(np.abs(signals[0]))
    plt.title("First Readout Signal")
    
    plt.tight_layout()
    plt.savefig("/root/output/ReconstructedMRI/debug.png")


# Run simulation
if __name__ == "__main__":
    # Run full simulation
    try:
        k_space, t, B1 = simulateMultiTR(Nx, Ny, Nz, T1_reshaped, T2_reshaped)
    except:
        print("simulateMultiTR error")

    #history = [np.array(h) for h in history]
    #print(f"Mx Mean: {np.mean(history)}, My Mean: {np.mean(history)}, Mx Mean: {np.mean(history)}")
    try:
        plot_signal_evolution(k_space, B1)
    except:
        print("plot signal evo error")

    # Reconstruction
    def reconstruct_image(k_space_slice):
        # Apply proper k-space centering
        k_centered = np.fft.ifftshift(k_space_slice)
        image = np.fft.ifft2(k_centered)
        return np.abs(image)
    
    # Display results
    fig, axes = plt.subplots(1, 3, figsize=(15, 5))
    
    # Middle slice k-space magnitude
    mid_slice = k_space[:, Nz//2, :]
    axes[0].imshow(np.log(np.abs(mid_slice) + 1e-9), cmap='viridis')
    axes[0].set_title("k-Space (Magnitude)")
    
    # Reconstructed image
    recon_image = reconstruct_image(mid_slice)
    axes[1].imshow(recon_image, cmap='gray')
    axes[1].set_title("Reconstructed Image")
    
    # Difference image
    diff_image = np.abs(recon_image - np.rot90(recon_image, 2))
    axes[2].imshow(diff_image, cmap='hot')
    axes[2].set_title("Symmetry Difference")

    
    plt.tight_layout()
    #plt.savefig("/root/output/ReconstructedMRI/mri_result", dpi = 300)

    plt.show()


