import numpy as np
import matplotlib.pyplot as plt
from scipy.spatial.transform import Rotation
from mpl_toolkits.mplot3d import Axes3D

# Constants
gamma = 42.577e6 * 2 * np.pi  # Gyromagnetic ratio (rad/s/T)

class SpinSystem:
    def __init__(self, positions, M0=1.0, T1=1.0, T2=0.1):
        """
        Initialize the spin system.
        
        Parameters:
            positions (np.array): Nx3 array of spin positions (x, y, z) in meters
            M0 (float): Equilibrium magnetization
            T1 (float): Longitudinal relaxation time (s)
            T2 (float): Transverse relaxation time (s)
        """
        self.positions = positions
        self.n_spins = positions.shape[0]
        self.M = np.zeros((self.n_spins, 3))
        self.M[:, 2] = M0  # Initial magnetization along z-axis
        self.T1 = T1
        self.T2 = T2
        self.M0 = M0

    def apply_rf_gradient(self, B1, G, t, rf_phase=0): #RF and Gz 
        """
        Apply RF pulse with simultaneous gradient.
        
        Parameters:
            B1 (np.array): RF waveform (T)
            G (np.array): Gradient waveform (Nx3) (T/m)
            t (np.array): Time points (s)
            rf_phase (float): Phase of RF pulse (rad)
        """
        dt = t[1] - t[0]
        
        for i in range(len(t)):
            # Effective B-field components
            B_eff = np.zeros((self.n_spins, 3))
            B_eff[:, 0] = B1[i] * np.cos(rf_phase)
            B_eff[:, 1] = B1[i] * np.sin(rf_phase)
            B_eff[:, 2] = np.dot(self.positions, G[i])
            
            # Rotation angle and axis
            rotation_angle = gamma * np.linalg.norm(B_eff, axis=1) * dt
            rotation_axis = B_eff / np.linalg.norm(B_eff, axis=1, keepdims=True)
            
            # Apply rotation to each spin
            for j in range(self.n_spins):
                if rotation_angle[j] > 1e-10:  # Avoid division by zero
                    rot = Rotation.from_rotvec(rotation_axis[j] * rotation_angle[j])
                    self.M[j] = rot.apply(self.M[j])
            
            # Apply relaxation during pulse
            self.M[:, :2] *= np.exp(-dt / self.T2) #Everything except Mz    
            self.M[:, 2] = self.M0 - (self.M0 - self.M[:, 2]) * np.exp(-dt / self.T1) #Mz

    def apply_gradient(self, G, duration): #both Gx and Gy 
        """
        Apply gradient for phase encoding or readout.
        
        Parameters:
            G (np.array): 3D gradient vector (T/m)
            duration (float): Gradient duration (s)
        """
        # Phase accumulation due to gradient
        phase_accumulation = gamma * duration * np.dot(self.positions, G)
        
        # Convert Mxy to complex for easy phase rotation
        Mxy = self.M[:, 0] + 1j * self.M[:, 1]
        Mxy *= np.exp(-1j * phase_accumulation)
        
        # Apply relaxation
        decay = np.exp(-duration / self.T2)
        Mxy *= decay
        self.M[:, 2] = self.M0 - (self.M0 - self.M[:, 2]) * np.exp(-duration / self.T1)
        
        # Convert back to real components
        self.M[:, 0] = Mxy.real
        self.M[:, 1] = Mxy.imag

    def acquire_signal(self, G_read, t_read, adc_delay=0):
        """
        Acquire signal during readout gradient.
        
        Parameters:
            G_read (np.array): Readout gradient (T/m)
            t_read (np.array): Readout time points (s)
            adc_delay (float): Delay before ADC starts (s)
            
        Returns:
            np.array: Acquired signal (complex)
        """
        dt = t_read[1] - t_read[0]
        signal = np.zeros(len(t_read), dtype=complex)
        
        # Apply ADC delay
        if adc_delay > 0:
            self.apply_gradient(G_read, adc_delay)
        
        # Readout loop
        for i, ti in enumerate(t_read):
            # Apply gradient for one timestep
            self.apply_gradient(G_read, dt)
            
            # Sum transverse magnetization
            signal[i] = np.sum(self.M[:, 0] + 1j * self.M[:, 1])
            
        return signal

    def reset_magnetization(self):
        """Reset magnetization to equilibrium."""
        self.M[:, :] = 0
        self.M[:, 2] = self.M0

def design_sinc_rf(flip_angle, duration, n_lobes=4, bandwidth=2000):
    """
    Design a slice-selective sinc RF pulse.
    
    Parameters:
        flip_angle (float): Target flip angle (rad)
        duration (float): Pulse duration (s)
        n_lobes (int): Number of sinc lobes
        bandwidth (float): Pulse bandwidth (Hz)
        
    Returns:
        tuple: (B1 waveform, time array)
    """
    t = np.linspace(-duration/2, duration/2, 100)
    lobe_factor = 2 * n_lobes / duration
    envelope = np.sinc(lobe_factor * t)
    
    # Normalize for flip angle
    area = np.trapz(envelope, t)
    B1_max = flip_angle / (gamma * area)
    B1 = B1_max * envelope
    
    return B1, t

def simulate_mri_sequence():
    """Full MRI sequence simulation."""
    # Create spin system (5x5 grid in a slice)
    x = np.linspace(-0.05, 0.05, 5)
    y = np.linspace(-0.05, 0.05, 5)
    z = np.array([0])  # Single slice
    X, Y, Z = np.meshgrid(x, y, z)
    positions = np.vstack([X.ravel(), Y.ravel(), Z.ravel()]).T
    spins = SpinSystem(positions, T1=0.8, T2=0.05)
    
    # Design RF pulse (90Â° flip)
    B1, t_rf = design_sinc_rf(np.pi/2, 2e-3)
    G_slice = np.array([0, 0, 0.01])  # Slice-select gradient (T/m)
    
    # Apply slice-selective excitation
    spins.apply_rf_gradient(B1, np.tile(G_slice, (len(t_rf), 1)), t_rf)
    
    # Phase encoding
    G_phase = np.array([0, 0.005, 0])  # Phase-encode gradient (T/m)
    spins.apply_gradient(G_phase, 2e-3)
    
    # Readout parameters
    t_read = np.linspace(0, 5e-3, 128)
    G_read = np.array([0.01, 0, 0])  # Readout gradient (T/m)
    
    # Acquire signal
    signal = spins.acquire_signal(G_read, t_read)
    
    return signal, spins

# Run simulation and plot results
signal, spins = simulate_mri_sequence()

# Plot results
plt.figure(figsize=(12, 8))

# Magnetization vectors
ax1 = plt.subplot(221, projection='3d')
for m in spins.M:
    ax1.quiver(0, 0, 0, m[0], m[1], m[2], length=0.5, normalize=True)
ax1.set_title('Magnetization Vectors')
ax1.set_xlim([-1, 1])
ax1.set_ylim([-1, 1])
ax1.set_zlim([-1, 1])

# Signal
plt.subplot(222)
plt.plot(np.real(signal), label='Real')
plt.plot(np.imag(signal), label='Imag')
plt.plot(np.abs(signal), label='Magnitude')
plt.title('Acquired Signal')
plt.xlabel('Time point')
plt.ylabel('Signal (a.u.)')
plt.legend()

# Position of spins
plt.subplot(223)
plt.scatter(spins.positions[:, 0], spins.positions[:, 1])
plt.title('Spin Positions')
plt.xlabel('x (m)')
plt.ylabel('y (m)')

# Mxy distribution
plt.subplot(224)
Mxy = np.abs(spins.M[:, 0] + 1j * spins.M[:, 1])
plt.scatter(spins.positions[:, 0], spins.positions[:, 1], c=Mxy, cmap='viridis')
plt.title('Transverse Magnetization (|Mxy|)')
plt.xlabel('x (m)')
plt.ylabel('y (m)')
plt.colorbar()

plt.tight_layout()
plt.show()